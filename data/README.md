# Blue Mountains Data Directory

This directory contains machine-readable data files generated by processing scripts. All files are excluded from Git (.gitignore) and regenerated from Zotero API when scripts run.

## Data Lifecycle

1. **Generation:** Scripts extract/analyse Zotero library data
2. **Storage:** Outputs saved to data/ directory
3. **Usage:** Consumed by subsequent scripts or external tools
4. **Archival:** Important datasets backed up to backups/ before major changes
5. **Regeneration:** Files can be regenerated at any time by rerunning scripts

**Note:** This directory should be empty in a fresh clone. Run `python scripts/01_extract_tags.py` to populate it.

## File Inventory

### Tag Extraction Data (from 01_extract_tags.py)

| File | Format | Size | Generated By | Purpose |
|------|--------|------|--------------|---------|
| `raw_tags.json` | JSON | ~500KB | 01_extract_tags.py | Complete tag extraction with metadata, statistics, item associations |
| `tag_frequency.csv` | CSV | ~30KB | 01_extract_tags.py | Tag usage frequencies, sorted descending |

### Tag Analysis Data (from 02_analyze_tags.py)

| File | Format | Size | Generated By | Purpose |
|------|--------|------|--------------|---------|
| `similar_tags.csv` | CSV | ~20KB | 02_analyze_tags.py | Tag pairs with similarity scores, consolidation recommendations |
| `tag_hierarchies.csv` | CSV | ~15KB | 02_analyze_tags.py | Detected parent-child tag relationships |
| `tag_network.json` | JSON | ~100KB | 02_analyze_tags.py | Tag co-occurrence data for network analysis |
| `quality_duplicates.csv` | CSV | ~5KB | 02_analyze_tags.py | Potential duplicate items flagged for review |
| `quality_non_primary_sources.csv` | CSV | ~40KB | 02_analyze_tags.py | Non-primary sources to exclude from analysis |
| `quality_multiple_attachments.csv` | CSV | ~10KB | 02_analyze_tags.py | Items with multiple attachments needing inspection |
| `quality_no_attachments.csv` | CSV | ~8KB | 02_analyze_tags.py | Items missing PDF/source documents |

### Attachment Inspection Data (from 03_inspect_multiple_attachments.py)

| File | Format | Size | Generated By | Purpose |
|------|--------|------|--------------|---------|
| `multiple_attachments_details.json` | JSON | ~50KB | 03_inspect_multiple_attachments.py | Full attachment metadata for flagged items |

## JSON File Specifications

### raw_tags.json

**Purpose:** Complete tag extraction from Zotero group library with full provenance

**Structure:**

```json
{
  "metadata": {
    "generated_at": "ISO-8601 timestamp",
    "zotero_group_id": "string",
    "statistics": {
      "total_items": "integer",
      "items_with_tags": "integer",
      "items_without_tags": "integer",
      "unique_tags": "integer",
      "total_tag_applications": "integer",
      "avg_tags_per_item": "float",
      "max_tags_per_item": "integer",
      "min_tags_per_item": "integer"
    }
  },
  "tags": {
    "tag_name": {
      "count": "integer - number of items using this tag",
      "items": ["array of Zotero item keys"],
      "item_titles": ["array of item titles"]
    }
  }
}
```

**Example:**

```json
{
  "metadata": {
    "generated_at": "2025-10-09T10:30:00+11:00",
    "zotero_group_id": "2258643",
    "statistics": {
      "total_items": 1189,
      "items_with_tags": 336,
      "unique_tags": 481
    }
  },
  "tags": {
    "Mining": {
      "count": 32,
      "items": ["ABC123XYZ", "DEF456UVW"],
      "item_titles": ["Katoomba Daily article 1901", "Mining report 1905"]
    }
  }
}
```

**Usage:**

- Input for 02_analyze_tags.py
- Can be loaded by external tools for custom analysis
- Contains full provenance (which items use which tags)

**See also:** docs/data-formats.md for complete JSON schema specification

---

### tag_network.json

**Purpose:** Tag co-occurrence data for network analysis and visualisation

**Structure:**

```json
{
  "metadata": {
    "generated_at": "ISO-8601 timestamp",
    "source_file": "raw_tags.json",
    "total_items_analysed": "integer",
    "unique_tags": "integer",
    "total_cooccurrences": "integer"
  },
  "cooccurrences": [
    {
      "tag1": "string",
      "tag2": "string",
      "count": "integer - how many items have both tags",
      "tag1_total": "integer - total usage of tag1",
      "tag2_total": "integer - total usage of tag2",
      "jaccard": "float - Jaccard similarity coefficient (future)"
    }
  ]
}
```

**Sorting:** Cooccurrences sorted by count (descending)

**Usage:**

- Generate network graphs (networkx, Gephi, Cytoscape)
- Identify related concepts
- Inform hierarchical vocabulary structure

---

### multiple_attachments_details.json

**Purpose:** Detailed attachment metadata for items flagged in quality checks

**Structure:**

```json
{
  "metadata": {
    "generated_at": "ISO-8601 timestamp",
    "source_file": "quality_multiple_attachments.csv",
    "total_items": "integer"
  },
  "items": [
    {
      "key": "Zotero item key",
      "title": "Item title",
      "itemType": "Zotero item type",
      "children": [
        {
          "key": "Attachment key",
          "itemType": "attachment | note",
          "contentType": "application/pdf | text/html | etc",
          "filename": "PDF filename",
          "title": "Note title",
          "note": "Note content (HTML)"
        }
      ],
      "category": "multiple_pdfs | pdf_plus_notes | multiple_notes | mixed_content | uncertain",
      "reasoning": "Human-readable categorisation explanation",
      "action": "HIGH PRIORITY | REVIEW | LOW PRIORITY"
    }
  ]
}
```

**Usage:**

- Manual review of attachment patterns
- Identify items that may combine multiple sources
- Guide curation decisions (split vs keep together)

## CSV File Specifications

### tag_frequency.csv

**Columns:**

| Column | Type | Description | Example |
|--------|------|-------------|---------|
| `tag` | string | Tag name | "Mining" |
| `count` | integer | Number of items using this tag | 32 |
| `percentage` | float | Percentage of tagged items using this tag | 9.52 |

**Sorting:** Descending by count (most frequent first)

**Usage:**

- Quick overview of tag usage
- Identify most/least common tags
- Import to Excel/LibreOffice for analysis
- Visualisation (bar charts, word clouds)

---

### similar_tags.csv

**Columns:**

| Column | Type | Description | Example |
|--------|------|-------------|---------|
| `tag1` | string | First tag name | "Mine" |
| `tag2` | string | Second tag name | "Mining" |
| `count1` | integer | Usage count of tag1 | 15 |
| `count2` | integer | Usage count of tag2 | 32 |
| `similarity` | float (0-100) | Similarity score (Levenshtein-based) | 83.3 |
| `ratio` | float (0-100) | Basic ratio similarity | 83.3 |
| `partial` | float (0-100) | Partial substring similarity | 100.0 |
| `token_sort` | float (0-100) | Token sort similarity | 83.3 |
| `suggested_merge` | string | Recommended tag to keep | "Mining" |

**Sorting:** Descending by similarity (most similar first)

**Usage:**

- Manual review for tag consolidation
- Merge suggested_merge recommendations
- Apply to Zotero library (manual or scripted)

**Note:** `suggested_merge` recommends keeping the tag with higher usage count

---

### tag_hierarchies.csv

**Columns:**

| Column | Type | Description | Example |
|--------|------|-------------|---------|
| `parent` | string | Parent (broader) tag | "Mining" |
| `child` | string | Child (narrower) tag | "Coal Mine" |
| `parent_count` | integer | Usage count of parent tag | 32 |
| `child_count` | integer | Usage count of child tag | 8 |
| `cooccurrence` | integer | Items with both tags | 6 |
| `relationship_type` | string | Detection method | "substring" or "cooccurrence" |

**Sorting:** By parent tag, then child tag (alphabetical)

**Usage:**

- Develop hierarchical taxonomy
- Inform SKOS broader/narrower relationships
- Guide controlled vocabulary structure

**Relationship Types:**

- **substring:** Child tag contains parent as substring ("Coal Mine" contains "Mine")
- **cooccurrence:** Tags frequently appear together (>50% of child tag usage)

---

### quality_duplicates.csv

**Columns:**

| Column | Type | Description | Example |
|--------|------|-------------|---------|
| `key` | string | Zotero item key | "ABC123XYZ" |
| `title` | string | Item title | "Mining accident at Katoomba" |
| `date` | string | Publication date | "1901-05-15" |
| `itemType` | string | Zotero item type | "newspaperArticle" |
| `numAttachments` | integer | Number of attachments | 1 |
| `numTags` | integer | Number of tags | 5 |

**Usage:**

- Manual review to identify true duplicates
- Check if items are identical or distinct
- Merge or delete as appropriate in Zotero

---

### quality_non_primary_sources.csv

**Columns:**

| Column | Type | Description | Example |
|--------|------|-------------|---------|
| `key` | string | Zotero item key | "DEF456UVW" |
| `title` | string | Item title | "Australian Dictionary of Biography" |
| `itemType` | string | Zotero item type | "encyclopediaArticle" |
| `creator` | string | Author/creator | "Smith, John" |
| `date` | string | Publication date | "1990" |
| `numTags` | integer | Number of tags | 0 |

**Usage:**

- Exclude from primary source analysis
- Separate reference works from archival sources
- Focus tagging efforts on primary sources

**Non-primary item types:**

- encyclopediaArticle, dictionaryEntry
- book (reference works, compilations)
- webpage (modern secondary sources)

---

### quality_multiple_attachments.csv

**Columns:**

| Column | Type | Description | Example |
|--------|------|-------------|---------|
| `key` | string | Zotero item key | "GHI789STU" |
| `title` | string | Item title | "Katoomba news collection" |
| `itemType` | string | Zotero item type | "newspaperArticle" |
| `numChildren` | integer | Total number of attachments/notes | 3 |
| `date` | string | Publication date | "1901" |
| `tags` | string | Comma-separated tag list | "Mining, Katoomba, Women" |

**Usage:**

- Input for 03_inspect_multiple_attachments.py
- Identify items that may combine multiple sources
- Flag for manual review and potential splitting

---

### quality_no_attachments.csv

**Columns:**

| Column | Type | Description | Example |
|--------|------|-------------|---------|
| `key` | string | Zotero item key | "JKL012MNO" |
| `title` | string | Item title | "Mining report 1905" |
| `itemType` | string | Zotero item type | "document" |
| `creator` | string | Author/creator | "NSW Mines Department" |
| `date` | string | Publication date | "1905" |
| `url` | string | External URL (if present) | "<http://trove.nla.gov.au/...>" |

**Usage:**

- Identify items missing source documents
- Add PDFs from archival sources
- Prioritise digitisation efforts

## File Naming Conventions

### Patterns

- **Tag data:** `tag_*.{json,csv}` (e.g., tag_frequency.csv, tag_network.json)
- **Quality checks:** `quality_*.csv` (e.g., quality_duplicates.csv)
- **Attachment details:** `*_attachments_*.{json,md}` (e.g., multiple_attachments_details.json)

### Case and Separators

- All lowercase
- Underscores (`_`) for word separation (snake_case)
- Descriptive nouns (not verbs)
- No dates in filenames (use metadata.generated_at in JSON)

### Versioning

Data files do not include version numbers. To preserve historical snapshots:

1. **Manual backup:** Copy important files to backups/ before major changes

   ```bash
   cp data/raw_tags.json backups/raw_tags_2025-10-09.json
   ```

2. **Timestamped archives:** Use ISO 8601 dates (YYYY-MM-DD)

3. **Git tracking:** Consider tracking select data files if they represent stable milestones

## Data Provenance and Reproducibility

### Generation Timestamps

All JSON files include `metadata.generated_at` with ISO 8601 timestamps:

```json
"metadata": {
  "generated_at": "2025-10-09T10:30:00+11:00"
}
```

**Time zone:** All timestamps use Australian Eastern Time (AEDT/AEST, UTC+10/+11)

### Source Attribution

Files document their source:

- **raw_tags.json:** Extracted from Zotero Group 2258643
- **tag_network.json:** Derived from raw_tags.json
- **multiple_attachments_details.json:** Derived from quality_multiple_attachments.csv + Zotero API

### Reproducibility

To reproduce data files:

1. Ensure .env configuration matches original (same Zotero library)
2. Run scripts in order: 01 → 02 → 03
3. Compare generated_at timestamps to verify freshness

**Note:** Results may differ if Zotero library has changed between runs (new items, modified tags)

### Zotero Library Version

To check current library state:

```bash
# Count items in library
python -c "from pyzotero import zotero; import config; \
           zot = zotero.Zotero(config.ZOTERO_GROUP_ID, 'group', config.ZOTERO_API_KEY_READONLY); \
           print(f'Total items: {len(zot.items())}')"
```

Compare with `metadata.statistics.total_items` in raw_tags.json to detect library changes.

## Usage Examples

### Loading JSON Data in Python

```python
import json
from pathlib import Path

# Load raw tags
with open('data/raw_tags.json', 'r', encoding='utf-8') as f:
    tag_data = json.load(f)

# Access metadata
print(f"Generated: {tag_data['metadata']['generated_at']}")
print(f"Total tags: {tag_data['metadata']['statistics']['unique_tags']}")

# Access tag information
mining_tag = tag_data['tags']['Mining']
print(f"'Mining' used on {mining_tag['count']} items")
print(f"Example item: {mining_tag['item_titles'][0]}")
```

### Loading CSV Data in Python (pandas)

```python
import pandas as pd

# Load tag frequency
freq_df = pd.read_csv('data/tag_frequency.csv')
print(freq_df.head(10))  # Top 10 tags

# Load similar tags
similar_df = pd.read_csv('data/similar_tags.csv')
high_similarity = similar_df[similar_df['similarity'] >= 90]
print(f"Found {len(high_similarity)} very similar pairs")
```

### Loading CSV in R

```r
library(readr)

# Load tag frequency
tag_freq <- read_csv("data/tag_frequency.csv")
head(tag_freq, 10)

# Visualise top 20 tags
library(ggplot2)
top_tags <- head(tag_freq, 20)
ggplot(top_tags, aes(x = reorder(tag, count), y = count)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Top 20 Most Frequent Tags",
       x = "Tag", y = "Usage Count")
```

### Network Analysis (networkx)

```python
import json
import networkx as nx
import matplotlib.pyplot as plt

# Load co-occurrence data
with open('data/tag_network.json', 'r') as f:
    network_data = json.load(f)

# Build graph
G = nx.Graph()
for pair in network_data['cooccurrences']:
    if pair['count'] >= 3:  # Filter weak connections
        G.add_edge(pair['tag1'], pair['tag2'], weight=pair['count'])

# Calculate centrality
centrality = nx.degree_centrality(G)
top_central = sorted(centrality.items(), key=lambda x: x[1], reverse=True)[:10]

print("Most central tags (hubiest):")
for tag, score in top_central:
    print(f"  {tag}: {score:.3f}")

# Visualise (small network)
if len(G.nodes()) <= 50:
    nx.draw_spring(G, with_labels=True, node_size=500)
    plt.savefig('tag_network_custom.png')
```

## Backup and Archival Strategy

### Why Backup Data?

Data files are regenerated from Zotero API, so they're technically reproducible. However, backup is valuable when:

1. **Library changes:** Zotero library may be modified between runs
2. **Milestone preservation:** Capture state at publication time
3. **Historical analysis:** Compare tag evolution over time
4. **Quality assurance:** Revert if regeneration produces unexpected results

### Backup Procedure

Before major changes (tag consolidation, library cleaning):

```bash
# Create timestamped backup directory
BACKUP_DATE=$(date +%Y-%m-%d)
mkdir -p backups/$BACKUP_DATE

# Copy important data files
cp data/raw_tags.json backups/$BACKUP_DATE/
cp data/tag_network.json backups/$BACKUP_DATE/
cp data/quality_*.csv backups/$BACKUP_DATE/

# Document backup
echo "Backup created: $(date)" > backups/$BACKUP_DATE/README.txt
echo "Purpose: Pre-tag consolidation snapshot" >> backups/$BACKUP_DATE/README.txt

echo "✓ Backup saved to backups/$BACKUP_DATE/"
```

### Retention Policy

- **Short-term backups:** Keep for 6 months (active development)
- **Milestone backups:** Keep indefinitely (publication, major releases)
- **Automated cleanup:** Remove backups older than 6 months (except milestones)

### Restoration

To restore from backup:

```bash
# List available backups
ls -l backups/

# Restore from specific date
cp backups/2025-10-09/raw_tags.json data/

# Verify restoration
python -c "import json; \
           data = json.load(open('data/raw_tags.json')); \
           print(f\"Restored data from: {data['metadata']['generated_at']}\")"
```

## See Also

- **docs/data-formats.md:** Complete JSON schema specifications
- **scripts/README.md:** Script execution guide and workflow
- **reports/README.md:** Report interpretation guide
- **CONTRIBUTING.md:** Data quality standards and validation procedures

---

## Questions?

- **Data format questions:** See docs/data-formats.md for detailed schemas
- **Missing files:** Run `python scripts/01_extract_tags.py` to generate
- **Corrupted files:** Delete and regenerate by rerunning scripts
- **Custom analysis:** Load JSON/CSV in your tool of choice (Python, R, Excel)
